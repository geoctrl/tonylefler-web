import { PropsTable } from "../props-table/props-table";
import { Example } from "../../components/docs";
import { Button } from "../button/button";
import { modalService } from "./modal-service";
import { ModalHeader } from "./components/modal-header";
import { ModalBody } from "./components/modal-body";
import { ModalFooter } from "./components/modal-footer";
import { useModalContext } from "./modal-context";
import { Input } from "../input/input";
import { useState } from "react";

export const meta = {
  title: 'Modal',
  category: 'components',
  order: 7
};

# Modal

A flexible modal system for creating self-contained, reusable dialogs and drawers using an imperative API.

## Import

```tsx
import {
  modalService,
  ModalHeader,
  ModalBody,
  ModalFooter,
  useModalContext
} from "root";
```

## Quick Start

```tsx
// Create a reusable modal configuration
const myModal = modalService.create(
  (props) => <YourModalComponent {...props} />,
  { size: "md" } // Modal options
);

// Use inside a component (recommended - auto-cleanup)
const openModal = myModal.hook();
await openModal({ data: "..." });

// Use programmatically (outside components)
myModal.open({ data: "..." });
```

## Philosophy

`modalService.create()` enables self-contained, reusable modals with intentional separation between the modal layer and the underlying page. Props passed to modals are **intentionally stale** - they don't update reactively like regular React props. This design maintains a clean separation between modal state and page state.

### No State Management Required

Traditional modal setups require managing open/close state in every component:

```tsx
// ❌ Traditional approach - repetitive state management
function MyComponent() {
  const [isModalOpen, setIsModalOpen] = useState(false);

  const handleDelete = () => {
    setIsModalOpen(true);
  };

  const onConfirm = () => {
    setIsModalOpen(false);
    // Now delete the file
  };

  return (
    <>
      <Button onClick={handleDelete}>Delete</Button>
      <Modal show={isModalOpen} onClose={() => setIsModalOpen(false)}>
        {/* Modal content */}
      </Modal>
    </>
  );
}
```

With `modalService`, the promise-based API eliminates this boilerplate:

```tsx
// ✅ Promise-based approach - clean and direct
function MyComponent() {
  const openConfirm = confirmModal.hook();

  const handleDelete = async () => {
    if (await openConfirm({ message: "Delete this file?" })) {
      // Delete the file - no state management needed
    }
  };
}
```

This is especially powerful for "chicken switch" patterns (confirmation dialogs):

```tsx
if (await deleteFileCheckModal()) {
  deleteFile();
}
```

The promise resolves with the modal's return value, streamlining conditional logic and eliminating state management overhead.

## Basic Usage

Define modals at **module level** with `modalService.create()`, then use the `.hook()` method inside components:

<Example>
  {(() => {
    // Define modal at module level
    const welcomeModal = modalService.create(
      (props) => {
        const { closeModal } = useModalContext();
        return (
          <>
            <ModalHeader title={props.title} />
            <ModalBody>
              <p>{props.message}</p>
            </ModalBody>
            <ModalFooter>
              <Button onClick={() => closeModal()}>Close</Button>
            </ModalFooter>
          </>
        );
      },
      { size: "md" }
    );

    // Use inside component
    function Example() {
      const openWelcome = welcomeModal.hook();

      return (
        <Button onClick={() => openWelcome({
          title: "Welcome",
          message: "This is a simple modal dialog."
        })}>
          Open Modal
        </Button>
      );
    }

    return <Example />;
  })()}
</Example>

```tsx
// Define modal at module level (outside component)
const welcomeModal = modalService.create(
  (props) => {
    const { closeModal } = useModalContext();
    return (
      <>
        <ModalHeader title={props.title} />
        <ModalBody>
          <p>{props.message}</p>
        </ModalBody>
        <ModalFooter>
          <Button onClick={() => closeModal()}>Close</Button>
        </ModalFooter>
      </>
    );
  },
  { size: "md" } // Modal options - set once at creation
);

// Use inside component with .hook()
function MyComponent() {
  const openWelcome = welcomeModal.hook();

  return (
    <Button onClick={() => openWelcome({
      title: "Welcome",
      message: "Hello!"
    })}>
      Open Modal
    </Button>
  );
}
```

## The create() Method

`modalService.create()` takes two arguments:

1. **Component function**: Receives props passed when opening the modal
2. **Modal options**: Size, position, and behavior options (set once, reused for all opens)

Returns an object with: `{ id, hook, open, update, close }`

### Why use .hook()?

The `.hook()` method is **recommended** because it ties the modal to the component lifecycle - the modal automatically closes when the component unmounts, preventing memory leaks.

<Example>
  {(() => {
    const lifecycleModal = modalService.create(
      (props) => {
        const { closeModal } = useModalContext();
        return (
          <>
            <ModalHeader title="Lifecycle Demo" />
            <ModalBody>
              <p>This modal will auto-close if the button component unmounts.</p>
              <p className="mt-2 text-sm opacity-50">
                Try navigating away while the modal is open.
              </p>
            </ModalBody>
            <ModalFooter>
              <Button onClick={() => closeModal()}>Close</Button>
            </ModalFooter>
          </>
        );
      }
    );

    function Example() {
      const openModal = lifecycleModal.hook(); // Auto-cleanup on unmount

      return (
        <Button onClick={() => openModal()}>
          Open Modal (with auto-cleanup)
        </Button>
      );
    }

    return <Example />;
  })()}
</Example>

```tsx
function MyComponent() {
  const openModal = myModal.hook(); // ✅ Recommended - auto-closes on unmount

  return <Button onClick={() => openModal({ ... })}>Open</Button>;
}
```

### When to use .open()

Use `.open()` when you need to open a modal **outside** a React component (event handlers, utility functions, etc.):

```tsx
const myModal = modalService.create(...);

// Outside component - no auto-cleanup
function handleGlobalEvent() {
  myModal.open({ message: "Event triggered!" });
}
```

## Return Values

Modals return promises that resolve when closed, enabling confirmation patterns:

<Example>
  {(() => {
    const confirmModal = modalService.create(
      (props) => {
        const { closeModal } = useModalContext();
        return (
          <>
            <ModalHeader title={props.title} />
            <ModalBody>
              <p>{props.message}</p>
            </ModalBody>
            <ModalFooter>
              <Button onClick={() => closeModal(false)}>Cancel</Button>
              <Button intent="primary" onClick={() => closeModal(true)}>
                {props.confirmText || "Confirm"}
              </Button>
            </ModalFooter>
          </>
        );
      },
      { size: "sm" }
    );

    function Example() {
      const openConfirm = confirmModal.hook();
      const [lastResult, setLastResult] = useState(null);

      const handleDelete = async () => {
        const confirmed = await openConfirm({
          title: "Delete Item",
          message: "Are you sure you want to delete this item?",
          confirmText: "Delete"
        });

        setLastResult(confirmed ? "Confirmed" : "Cancelled");
      };

      return (
        <div className="flex items-center gap-2">
          <Button onClick={handleDelete}>Delete Item</Button>
          {lastResult && (
            <span className="text-sm opacity-50">
              Result: {lastResult}
            </span>
          )}
        </div>
      );
    }

    return <Example />;
  })()}
</Example>

```tsx
const confirmModal = modalService.create(
  (props) => {
    const { closeModal } = useModalContext();
    return (
      <>
        <ModalHeader title="Confirm" />
        <ModalBody>{props.message}</ModalBody>
        <ModalFooter>
          <Button onClick={() => closeModal(false)}>Cancel</Button>
          <Button intent="primary" onClick={() => closeModal(true)}>
            Confirm
          </Button>
        </ModalFooter>
      </>
    );
  },
  { size: "sm" }
);

function MyComponent() {
  const openConfirm = confirmModal.hook();

  const handleDelete = async () => {
    const confirmed = await openConfirm({
      message: "Are you sure?"
    });

    if (confirmed) {
      // Proceed with deletion
    }
  };
}
```

## Building Modal Content

Use the provided components to structure your modal:

### ModalHeader

<Example>
  {(() => {
    const headerModal = modalService.create(
      (props) => {
        const { closeModal } = useModalContext();
        return (
          <>
            <ModalHeader
              title="Settings"
              description="Manage your account preferences"
              actions={
                <Button formSize="sm" intent="tertiary">
                  Help
                </Button>
              }
            />
            <ModalBody>
              <p>Modal content goes here.</p>
            </ModalBody>
          </>
        );
      }
    );

    function Example() {
      const openModal = headerModal.hook();
      return (
        <Button onClick={() => openModal()}>
          Modal with Header Actions
        </Button>
      );
    }

    return <Example />;
  })()}
</Example>

```tsx
<ModalHeader
  title="Settings"
  description="Manage your account preferences"
  actions={
    <Button formSize="sm" intent="tertiary">
      Help
    </Button>
  }
/>
```

### ModalBody

The body provides proper spacing and scroll behavior:

```tsx
<ModalBody>
  <p>Your modal content...</p>
</ModalBody>
```

### ModalFooter

Footer with action buttons, right-aligned by default:

```tsx
<ModalFooter>
  <Button onClick={() => closeModal()}>Cancel</Button>
  <Button intent="primary" onClick={() => closeModal()}>
    Save Changes
  </Button>
</ModalFooter>
```

## Sizes

Control modal width with the `size` option in `modalService.create()`:

<Example>
  {(() => {
    const smallModal = modalService.create(
      (props) => {
        const { closeModal } = useModalContext();
        return (
          <>
            <ModalHeader title="Small Modal" />
            <ModalBody>
              <p>This is a small modal (300px).</p>
            </ModalBody>
            <ModalFooter>
              <Button onClick={() => closeModal()}>Close</Button>
            </ModalFooter>
          </>
        );
      },
      { size: "sm" }
    );

    const mediumModal = modalService.create(
      (props) => {
        const { closeModal } = useModalContext();
        return (
          <>
            <ModalHeader title="Medium Modal" />
            <ModalBody>
              <p>This is a medium modal (400px).</p>
            </ModalBody>
            <ModalFooter>
              <Button onClick={() => closeModal()}>Close</Button>
            </ModalFooter>
          </>
        );
      },
      { size: "md" }
    );

    const largeModal = modalService.create(
      (props) => {
        const { closeModal } = useModalContext();
        return (
          <>
            <ModalHeader title="Large Modal" />
            <ModalBody>
              <p>This is a large modal (560px).</p>
            </ModalBody>
            <ModalFooter>
              <Button onClick={() => closeModal()}>Close</Button>
            </ModalFooter>
          </>
        );
      },
      { size: "lg" }
    );

    function Example() {
      const openSmall = smallModal.hook();
      const openMedium = mediumModal.hook();
      const openLarge = largeModal.hook();

      return (
        <div className="flex gap-2">
          <Button onClick={() => openSmall()}>Small</Button>
          <Button onClick={() => openMedium()}>Medium</Button>
          <Button onClick={() => openLarge()}>Large</Button>
        </div>
      );
    }

    return <Example />;
  })()}
</Example>

```tsx
modalService.create(MyModal, { size: "sm" }); // 300px
modalService.create(MyModal, { size: "md" }); // 400px (default)
modalService.create(MyModal, { size: "lg" }); // 560px
```

## Drawer Variant

Use `modalType: "drawer"` for a slide-in drawer from the right:

<Example>
  {(() => {
    const drawerModal = modalService.create(
      (props) => {
        const { closeModal } = useModalContext();
        return (
          <>
            <ModalHeader title="Drawer Panel" />
            <ModalBody>
              <p>This drawer slides in from the right side.</p>
              <p className="mt-4">Drawers are great for:</p>
              <ul className="mt-2 list-disc pl-5">
                <li>Side panels</li>
                <li>Filter panels</li>
                <li>Navigation menus</li>
                <li>Settings panels</li>
              </ul>
            </ModalBody>
            <ModalFooter>
              <Button onClick={() => closeModal()}>Close</Button>
            </ModalFooter>
          </>
        );
      },
      { modalType: "drawer", size: "md" }
    );

    function Example() {
      const openDrawer = drawerModal.hook();
      return <Button onClick={() => openDrawer()}>Open Drawer</Button>;
    }

    return <Example />;
  })()}
</Example>

```tsx
const myDrawer = modalService.create(
  MyDrawerContent,
  { modalType: "drawer", size: "md" }
);
```

## Position

Control vertical positioning with the `position` option:

<Example>
  {(() => {
    const topModal = modalService.create(
      (props) => {
        const { closeModal } = useModalContext();
        return (
          <>
            <ModalHeader title="Top Positioned" />
            <ModalBody>
              <p>This modal appears near the top of the viewport.</p>
            </ModalBody>
            <ModalFooter>
              <Button onClick={() => closeModal()}>Close</Button>
            </ModalFooter>
          </>
        );
      },
      { position: "top" }
    );

    const centerModal = modalService.create(
      (props) => {
        const { closeModal } = useModalContext();
        return (
          <>
            <ModalHeader title="Center Positioned" />
            <ModalBody>
              <p>This modal appears centered in the viewport.</p>
            </ModalBody>
            <ModalFooter>
              <Button onClick={() => closeModal()}>Close</Button>
            </ModalFooter>
          </>
        );
      },
      { position: "center" }
    );

    function Example() {
      const openTop = topModal.hook();
      const openCenter = centerModal.hook();

      return (
        <div className="flex gap-2">
          <Button onClick={() => openTop()}>Top Position</Button>
          <Button onClick={() => openCenter()}>Center Position</Button>
        </div>
      );
    }

    return <Example />;
  })()}
</Example>

```tsx
modalService.create(MyModal, { position: "top" });
modalService.create(MyModal, { position: "center" }); // default
```

## Advanced Features

### Disable Backdrop Click

Prevent closing the modal by clicking outside:

<Example>
  {(() => {
    const requiredModal = modalService.create(
      (props) => {
        const { closeModal } = useModalContext();
        return (
          <>
            <ModalHeader title="Required Action" />
            <ModalBody>
              <p>You must click a button to close this modal.</p>
              <p className="mt-2 text-sm opacity-50">
                Clicking outside won't close it.
              </p>
            </ModalBody>
            <ModalFooter>
              <Button onClick={() => closeModal()}>Close</Button>
            </ModalFooter>
          </>
        );
      },
      { disableBackdropClick: true }
    );

    function Example() {
      const openModal = requiredModal.hook();
      return <Button onClick={() => openModal()}>Required Modal</Button>;
    }

    return <Example />;
  })()}
</Example>

```tsx
modalService.create(MyModal, { disableBackdropClick: true });
```

### Expand Height

Make the modal fill the available height:

<Example>
  {(() => {
    const expandedModal = modalService.create(
      (props) => {
        const { closeModal } = useModalContext();
        return (
          <>
            <ModalHeader title="Full Height Modal" />
            <ModalBody>
              <p>This modal expands to fill the available viewport height.</p>
              <p className="mt-4">Great for:</p>
              <ul className="mt-2 list-disc pl-5">
                <li>Long forms</li>
                <li>Data tables</li>
                <li>Content-heavy modals</li>
              </ul>
            </ModalBody>
            <ModalFooter>
              <Button onClick={() => closeModal()}>Close</Button>
            </ModalFooter>
          </>
        );
      },
      { expandHeight: true }
    );

    function Example() {
      const openModal = expandedModal.hook();
      return <Button onClick={() => openModal()}>Expanded Modal</Button>;
    }

    return <Example />;
  })()}
</Example>

```tsx
modalService.create(MyModal, { expandHeight: true });
```

### Dynamic Updates

Use `.update()` to non-disruptively update modal props while it's open. Useful for showing notifications when underlying data changes:

<Example>
  {(() => {
    const updatableModal = modalService.create(
      (props) => {
        const { closeModal } = useModalContext();
        return (
          <>
            <ModalHeader title="Live Data" />
            <ModalBody>
              {props.dataChanged && (
                <div className="mb-4 rounded border border-warning-500 bg-warning-50 p-3 dark:bg-warning-950">
                  <p className="text-sm font-medium">Data has changed</p>
                  <p className="mt-1 text-xs opacity-75">
                    The underlying data was updated. Click reload to refresh.
                  </p>
                  <Button
                    formSize="sm"
                    intent="tertiary"
                    className="mt-2"
                    onClick={() => {
                      // Reload data logic here
                      alert("Reloading data...");
                    }}
                  >
                    Reload
                  </Button>
                </div>
              )}
              <p>Current value: {props.value}</p>
            </ModalBody>
            <ModalFooter>
              <Button onClick={() => closeModal()}>Close</Button>
            </ModalFooter>
          </>
        );
      }
    );

    function Example() {
      const openModal = updatableModal.hook();
      const [value, setValue] = useState(42);

      const handleOpen = () => {
        openModal({ value, dataChanged: false });
      };

      const handleUpdateData = () => {
        const newValue = Math.floor(Math.random() * 100);
        setValue(newValue);
        updatableModal.update({ value: newValue, dataChanged: true });
      };

      return (
        <div className="flex gap-2">
          <Button onClick={handleOpen}>Open Modal</Button>
          <Button intent="tertiary" onClick={handleUpdateData}>
            Update Data
          </Button>
        </div>
      );
    }

    return <Example />;
  })()}
</Example>

```tsx
const myModal = modalService.create(
  (props) => {
    const { closeModal } = useModalContext();
    return (
      <>
        <ModalHeader title="Live Data" />
        <ModalBody>
          {props.dataChanged && (
            <div className="notification">
              Data has changed.
              <Button onClick={reloadData}>Reload</Button>
            </div>
          )}
          <p>Current value: {props.value}</p>
        </ModalBody>
      </>
    );
  }
);

// Later, when data changes:
myModal.update({ value: newValue, dataChanged: true });
```

**Note**: Props are intentionally stale and don't react to changes. Use `.update()` sparingly for non-disruptive notifications only.

## API Reference

### modalService.create()

Creates a reusable modal configuration.

<PropsTable props={[
  {
    name: "component",
    type: "(props: T) => ReactNode",
    description: "Component function that receives props passed during open",
    required: true,
  },
  {
    name: "options",
    type: "ModalOpts",
    description: "Configuration options applied to all opens of this modal",
    required: false,
  },
]} />

**Returns**: `{ id, hook, open, update, close }`

<PropsTable props={[
  {
    name: "id",
    type: "string",
    description: "Unique identifier for this modal instance",
    required: false,
  },
  {
    name: "hook",
    type: "() => (props?: T) => Promise<any>",
    description: "React hook that returns an open function with auto-cleanup (recommended)",
    required: false,
  },
  {
    name: "open",
    type: "(props?: T) => Promise<any>",
    description: "Manually open the modal (use outside components)",
    required: false,
  },
  {
    name: "update",
    type: "(props?: Partial<T>) => void",
    description: "Update modal props while it's open (use sparingly)",
    required: false,
  },
  {
    name: "close",
    type: "(result?: any) => void",
    description: "Programmatically close the modal",
    required: false,
  },
]} />

### ModalOpts

<PropsTable props={[
  {
    name: "size",
    type: '"sm" | "md" | "lg"',
    description: "Width of the modal",
    default: '"md"',
    required: false,
  },
  {
    name: "modalType",
    type: '"modal" | "drawer"',
    description: "Display as centered modal or right-side drawer",
    default: '"modal"',
    required: false,
  },
  {
    name: "position",
    type: '"center" | "top"',
    description: "Vertical positioning of the modal",
    default: '"center"',
    required: false,
  },
  {
    name: "expandHeight",
    type: "boolean",
    description: "Fill available viewport height",
    default: "false",
    required: false,
  },
  {
    name: "disableBackdropClick",
    type: "boolean",
    description: "Prevent closing by clicking outside the modal",
    default: "false",
    required: false,
  },
]} />

### useModalContext()

Access modal context from within a modal component.

```tsx
const { closeModal } = useModalContext();
```

<PropsTable props={[
  {
    name: "closeModal",
    type: "(result?: any) => void",
    description: "Function to close the modal and optionally return a value",
    required: false,
  },
]} />

### ModalHeader

<PropsTable props={[
  {
    name: "title",
    type: "string | ReactNode",
    description: "The modal title",
    required: false,
  },
  {
    name: "description",
    type: "string",
    description: "Secondary text below the title",
    required: false,
  },
  {
    name: "actions",
    type: "ReactNode",
    description: "Additional action buttons to display in the header",
    required: false,
  },
  {
    name: "hideCloseButton",
    type: "boolean",
    description: "Hide the default close button",
    default: "false",
    required: false,
  },
]} />

### ModalBody

<PropsTable props={[
  {
    name: "className",
    type: "string",
    description: "Additional CSS classes",
    required: false,
  },
  {
    name: "children",
    type: "ReactNode",
    description: "Body content",
    required: false,
  },
]} />

### ModalFooter

<PropsTable props={[
  {
    name: "className",
    type: "string",
    description: "Additional CSS classes",
    required: false,
  },
  {
    name: "children",
    type: "ReactNode",
    description: "Footer content (typically buttons)",
    required: false,
  },
]} />

## Accessibility

- Focus is automatically trapped within the modal
- Pressing `Esc` closes the modal (unless `disableBackdropClick` is true)
- Clicking the backdrop closes the modal (unless `disableBackdropClick` is true)
- Focus returns to the triggering element when closed (when using `.hook()`)
- Proper ARIA roles and labels are applied
